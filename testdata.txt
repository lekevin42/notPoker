Assignment 3CS-452Spring 2017Due Date:  5/19/2017 at 11:59 pm (No extensions)You may work in groups of 6Goals:1.Designan application for creating and verifying le signatures.2.UtilizeRSA public key encryption algorithm.3.Experimentwith Python's cryptographic libraries.4.Appreciatethe challenges of developing cryptographic solutions.OverviewIn this assignment you will utilize RSA public key encryption to implement a utility for creatingand verifying digital signatures of les.Note:  You will not be implementing your own RSA algorithm.Instead, you will beusing Python's cryptographic libraries.You may work in groups of 6The sections that follow give the specics.Assignment FilesFileassig3skeleton.ziparchive provides a program skeleton and les with examples of howto generate and verify signatures.skeleton.py:The le where the main program is to be implemented.  The use of theskeleton le is optional.sha512.py:This le contains the code illustrating how to compute the hash a 512-bitdigest (i.e., hash) of any data using the SHA-512 algorithm (running:python sha512.py).signandverify.py:contains a simple example of generating and verifying digital signa-tures using RSA (running:python signandverify.py).pubKey.pem:The le containing a sample public key.privKey.pem:The le containing a sample private key.Your nished program shall be calledsigner.py, shall integrate both DES and shall be executedas:python signer.py <KEY FILE NAME> <SIGNATURE FILE NAME> <INPUT FILE NAME> <MODE>Each parameter is dened as follows:1
KEY FILE NAMEThe name of the le containing private key (if signing) or public key (whenverifying the digital signature).SIGNATURE FILE NAME:The le to which to save the digital signature (if signing) or fromwhich to load the digital signature (when verifying).INPUT FILE NAME:The le for which to generate or verify the digital signature.MODE:Can be one of the following:{sign:This mode tells the program to:1.  Read theINPUT FILE NAME2.  Compute an SHA-512 hash of the contents read3.  Encrypt the hash with theprivate keyfromKEY FILE NAMEle4.  Save the result (i.e., the digital signature) to theSIGNATURE FILE NAME.{verify:This mode tells the program to:1.  Read theINPUT FILE NAME.2.  Compute an SHA-512 hash of the contents read3.  Decrypt the signature fromSIGNATURE FILE NAMEusing thepublic keyfromleKEY FILE NAME4.  Compare the decrypted value against the SHA-512 hash, and output whether thesignature matches.Examples:bash$ python signer.py privKey.pem music.sig music.mp3 signSaved the signature of music.mp3 to music.sigbash$ python signer.py pubKey.pem music.sig music.mp3 verifySignatures match!bash$ python signer.py wrongPubKey.pem music.sig music.mp3 verifySignatures DO NOT MATCH!When invoked, the program will check the mode;  If the mode issign, the program will readthe private key from the specied.pemle, generate use SHA-512 to compute the hash of thele's contents, encrypt the output of SHA-512 using the RSA private key (please see thesign()function in signandverify.py), and write the resulting signature to the signature le.If the mode isverify, the program will read the public key from the specied.pemle, readthe signature from the specied signature le, and compute the SHA-512 hash of the data le'scontents.Next, it will decrypt the signature, and compare the result against the SHA-512 hash (pleasesee theverify()function insignandverify.py).  If they match, then the signature has beensuccessfully veried.  If they do not match, then the verication fails.  The program will outputthe result of the verication.NOTE:  SHA-512  hashing  algorithm  takes  (almost)  arbitrary  number  of  data  bytes  as  inputand based on the values of these bytes computes a 512-bit hexadecimal number.  The slightest2
changes in the input will result in tremendous changes in the output.  These properties makeSHA-512  very  useful  in  digital  signatures;  we  want  changes  in  the  signed  data  to  drasticallychange the signature.Hashing algorithms also make digital signatures more ecient:  instead of encrypting the entirele using the RSA private key (which would be very inecient),  we encrypt a 512-bit string.You must use Python, C++, or Java.  The skeleton was provided for Python.The sections that follow describe the functions in the skeleton leskeleton.py.  The TODOcomments inskeleton.pydescribe your tasks in completing the bodies of the functions below.loadKey(keyPath):This  function  loads  the  public  or  private  key  from  the  le  (e.g.,thepubKey.pemandprivKey.pemles provided) at the specied path (keyPath) and re-turns  an  object  representing  the  RSA  key.   The  object  supportssign()andverify()methods  used  for  generating  and  verifying  digital  signatures,  respectively  (please  seesignandverify.pysample for details).  This function was already completed for you.digSig(sigKey, string):  Encrypts a given string (string) using the specied privatekey (sigKey).  This can be done using thesign()method of the sigKey object.  Pleaseseesignandverify.pyfor details.getFileSig(fileName, privKey):Generates the digital signature of the le (fileName);Reads the contents of the le, computes the SHA-512 hash of the contents, signs the hashusingprivKeythedigSig()function, and returns the result.verifySig(theHash, sig, verifyKey):Veries the digital signature.  Decrypts the sig-nature  (sig)  using  the  specied  public  key  (sigKey),  compares  the  result  against  thespecied SHA-512 hash (theHash), and returns the result of the comparison.verifyFileSig(fileName, pubKey, signature):Veries  the  digital  signature  of  thele (fileName).  Reads the contents of the le (fileName), computes the SHA-512 hash ofthe contents, and callsverifySig()to compare the SHA-512 hash against the signature(signature) decrypted using the public key (pubKey).saveSig(fileName):saves the digital signature to a le (fileName). Please see theTODO:in the skeleton for more details.loadSig(fileName):loads  the  signature  from  le  (fileName)  and  returns  the  loadedsignature object.  Please see theTODO:in the skeleton for more details.Your task is to complete the TODO's in theskeleton.pyle and ensure that theresulting program correctly signs and veries digital signaturesof les.  You may ndthis tutorial a valuable resource http://www.laurentluce.com/posts/python-and-cryptography-with-pycrypto/.RUNNING YOUR PROGRAMYour programs must be implemented using Python, Java, or C++, and must compileand  run  on  the  Topaz1  server.   Please  follow  the  following  steps  in  order  to  connect  to  theTopaz1 server.  To access the Topaz1 server, please ask the instructor for credentials.  Once thecredentials are obtained, you can use the following process to connect:3
1.  Connect to the Topaz1 server:ssh <your provided user name>@topaz1.ecs.fullerton.edu.E.g.ssh mgofman@topaz1.ecs.fullerton.edu.2.  Enter your Topaz server credentials.You must also include aMakefile(if applicable) which compiles all of your code when the usertypesmakeat  the  command  line.   Simply  typemakeat  the  terminal  in  order  to  compile  theprogram.If you are not sure how to write or modify themakefileplease check the following resources.C++ make les:  http://www.delorie.com/djgpp/doc/ug/larger/makeles.htmlJava make les:  http://www.cs.swarthmore.edu/ newhall/unixhelp/javamakeles.htmlGoogle \writing Makeles"Ask the instructor (don't be afraid!)EXTRA CREDIT:Add a functionality to your program such that on signing embeds the signature in the le andgives the user the option to encrypt the le using AES (with the user-specied specied key).When the le is decrypted, the signature will also be veried and the user will be made aware ofthe whether it matches.  The resulting decrypted le must have the embedded signature removedfrom it.SUBMISSION GUIDELINES:This assignment may be completed using Python, Java, or C++.Please  hand  in  your  source  code  electronically  (do  not  submit  .o  or  executable  code)throughTITANIUM. You must make sure that this code compiles and runs correctly.Only one person within each group should submit.Write a README le (text le, do not submit a .doc le) which contains{Names and email addresses of all partners.{The programming language you used (e.g.  Python, Java, or C++){How to execute your program.{Whether you implemented the extra credit.{Anything special about your submission that we should take note of.Place  all  your  les  under  one  directory  with  a  unique  name  (such  asp1-[userid]forassignment 1, e.g.p1-mgofman1).Tar the contents of this directory using the following command.tar cvf [directoryname].tar[directoryname]E.g.tar -cvf p1-mgofman1.tar p1-mgofman1/4
Use TITANIUM to upload the tared le you created above.Grading guideline:Program runs:  5'Correct signature generation:  45'Correct signature verication:  45'README le included:  5'BONUS: 10 pointsLate submissions shall be penalized 10%.  No assignments shall be accepted after 24 hours.Academic Honesty:Academic Honesty:All forms of cheating shall be treated with utmost seriousness.  You maydiscuss  the  problems  with  other  students,  however,  you  must  write  yourOWN  codes  andsolutions.  Discussing solutions to the problem isNOTacceptable (unless specied otherwise).Copying  an  assignment  from  another  student  or  allowing  another  student  to  copy  your  workmay lead to an automatic F for this course.  Moss shall be used to detect plagiarism inprogramming assignments.  If you have any questions about whether an act of collaboration maybe treated as academic dishonesty, please consult the instructor before you collaborate.  Detailsposted at http://www.fullerton.edu/senate/documents/PDF/300/UPS300-021.pdf.5
